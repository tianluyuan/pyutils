import functools
import numpy as np
from scipy import optimize
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib import colors
import matplotlib.pyplot as plt


def multipage(filename, figs=None, dpi=200):
    """ http://stackoverflow.com/questions/26368876/saving-all-open-matplotlib-figures-in-one-file-at-once
    """
    pp = PdfPages(filename)
    if figs is None:
        figs = [plt.figure(n) for n in plt.get_fignums()]
    for fig in figs:
        fig.savefig(pp, format='pdf')
    pp.close()


def colorlines(x, y, ncolors=5, cmapname='viridis_r', **kwargs):
    """Plot a line plot in which the lines change colors as the data is
    stepped through.

    *ncolors* specifies the number of different colors to use
    """
    cmap = plt.get_cmap(cmapname)
    norm = colors.Normalize(vmin=0, vmax=ncolors-1)
    for i in range(ncolors):
        chunksize = len(x)/ncolors
        low = i*chunksize
        # add 1 to keep lines connected
        high = min((i+1)*chunksize+1, len(x))
        plt.plot(x[low:high], y[low:high], color=cmap(norm(i)), **kwargs)


def pdf(func):
    """ decorator to save all plots generated by func to pdf
    """
    @functools.wraps(func)
    def pdfwrapper(*args, **kwargs):
        if kwargs.has_key('pdffile') and kwargs['pdffile'] is not None:
            plt.close('all')

            ret = func(*args, **kwargs)
            multipage(kwargs['pdffile'])
            return ret
        else:
            return func(*args, **kwargs)

    return pdfwrapper


def new_lims(curr_lim, bounds):
    """checks whether the current limit exceeds the bounds and returns
    the appropriate new limits based on bounds or the current
    limit. Reverse order (i.e. left > right) is allowed and accounted for.
    """
    lb, rt = curr_lim
    if lb <= rt:
        # normal ordering
        combined = sorted(curr_lim+bounds)
        # no overlap
        if tuple(combined[:2]) == (lb, rt) or tuple(combined[2:]) == (lb, rt):
            return bounds[0], bounds[1]

        return combined[1], combined[2]
    else:
        # reverse ordering
        combined = sorted(curr_lim+bounds, reverse=True)
        # no overlap
        if tuple(combined[:2]) == (lb, rt) or tuple(combined[2:]) == (lb, rt):
            return bounds[0], bounds[1]

        return combined[1], combined[2]
    

def restrict_axes(ax, xlim=None, ylim=None):
    """Given a matplotlib axis *ax*, restricts the axis limits to xlim and
    ylim if they exceed the bounds (xlim, ylim). If the axis limit
    does not overlap with (xlim, ylim), the new limits are set to
    (xlim, ylim). Otherwise limits are kept as is.

    *xlim* and *ylim* are the restricted ranges and should be passed as tuples
    """
    if xlim is not None:
        ax.set_xlim(*new_lims(ax.get_xlim(), xlim), auto=None)
    if ylim is not None:
        ax.set_ylim(*new_lims(ax.get_ylim(), ylim), auto=None)
        

def contour_levels(x, y, cls=(0.95, 0.68), bins=None):
    """given 2D datapoints, return values of the pdf corresponding to the
    passed confidence levels
    """
    if bins is None:
        bins = int(np.sqrt(len(x)))
    # Make a 2d normed histogram
    H,xedges,yedges=np.histogram2d(x,y,bins=bins,normed=True)

    norm=H.sum() # Find the norm of the sum

    # Take histogram bin membership as proportional to Likelihood
    # This is true when data comes from a Markovian process
    def objective(limit, target):
        w = np.where(H>limit)
        count = H[w]
        return count.sum() - target

    levels = [optimize.bisect(objective, H.min(), H.max(), args=(cl*norm,))
              for cl in cls]
    levels.append(H.max())
    return levels


def hp_ticklabels(zoom=False, lonra=None, latra=None, rot=None):
    import healpy as hp
    # coordinate labels
    ax = plt.gca()
    azis = range(-150, 181, 30)
    zens = range(0, 181, 30)
    azi_offset = rot[0]+lonra[0] if zoom else -180
    zen_offset = rot[1]+latra[0] if zoom else 0
    for zc in zens:
        hp.projtext(azi_offset, 90-zc, "{:.0f}$^\circ$".format(zc), lonlat=True)
    if zoom:
        for ac in azis:
            hp.projtext(ac, zen_offset, "{:.0f}$^\circ$".format(ac), lonlat=True)
    else:
        ax.annotate(r"$\bf{-180^\circ}$", xy=(1.7, 0.625), size="medium")
        ax.annotate(r"$\bf{180^\circ}$", xy=(-1.95, 0.625), size="medium")
        ax.annotate('Detector', xy=(1, -1), size="medium")
