import functools
import numpy as np
from scipy import optimize
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib import colors
import matplotlib.patheffects as path_effects
import matplotlib.pyplot as plt
from collections import namedtuple


CoordSys = namedtuple('CoordSys', 'det eq gal')
COORD = CoordSys('Detector', 'Equatorial', 'Galactic')


def multipage(filename, figs=None, dpi=200):
    """
    Save multiple matplotlib figures to a single PDF file.

    Parameters
    ----------
    filename : str
        The name of the PDF file to save.
    figs : list of matplotlib.figure.Figure, optional
        List of figures to save. If None, all open figures are saved.
    dpi : int, optional
        The resolution in dots per inch.

    References
    ----------
    http://stackoverflow.com/questions/26368876/saving-all-open-matplotlib-figures-in-one-file-at-once
    """
    pp = PdfPages(filename)
    if figs is None:
        figs = [plt.figure(n) for n in plt.get_fignums()]
    for fig in figs:
        fig.savefig(pp, format='pdf')
    pp.close()


def colorlines(x, y, ncolors=5, cmapname='viridis_r', **kwargs):
    """
    Plot a line plot where lines change colors progressively.

    Parameters
    ----------
    x : pandas.Series
        x-coordinates of the data.
    y : pandas.Series
        y-coordinates of the data.
    ncolors : int, optional
        Number of colors to use.
    cmapname : str, optional
        Name of the colormap to use.
    **kwargs : dict
        Additional keyword arguments passed to `plt.plot`.
    """
    cmap = plt.get_cmap(cmapname)
    norm = colors.Normalize(vmin=0, vmax=ncolors-1)
    for i in range(ncolors):
        chunksize = len(x) // ncolors
        low = i * chunksize
        high = min((i + 1) * chunksize + 1, len(x))  # Add 1 to keep lines connected
        plt.plot(x.iloc[low:high], y.iloc[low:high], color=cmap(norm(i)), **kwargs)


def pdf(func):
    """
    Decorator to save all plots generated by a function to a PDF file.

    Parameters
    ----------
    func : callable
        The function whose plots should be saved to a PDF.

    Returns
    -------
    callable
        The wrapped function.
    """
    @functools.wraps(func)
    def pdfwrapper(*args, **kwargs):
        if 'pdffile' in kwargs and kwargs['pdffile'] is not None:
            plt.close('all')
            ret = func(*args, **kwargs)
            multipage(kwargs['pdffile'])
            return ret
        else:
            return func(*args, **kwargs)

    return pdfwrapper


def new_lims(curr_lim, bounds):
    """
    Determine new axis limits based on current limits and bounds.

    Parameters
    ----------
    curr_lim : tuple of float
        Current axis limits (lower, upper).
    bounds : tuple of float
        Bounds for the axis limits (lower, upper).

    Returns
    -------
    tuple of float
        New axis limits (lower, upper).
    """
    lb, rt = curr_lim
    if lb <= rt:
        # Normal ordering
        combined = sorted(curr_lim + bounds)
        # No overlap
        if tuple(combined[:2]) == (lb, rt) or tuple(combined[2:]) == (lb, rt):
            return bounds[0], bounds[1]

        return combined[1], combined[2]
    else:
        # Reverse ordering
        combined = sorted(curr_lim + bounds, reverse=True)
        # No overlap
        if tuple(combined[:2]) == (lb, rt) or tuple(combined[2:]) == (lb, rt):
            return bounds[0], bounds[1]

        return combined[1], combined[2]


def restrict_axes(ax, xlim=None, ylim=None):
    """
    Restrict axis limits to specified bounds.

    Given a matplotlib axis *ax*, restricts the axis limits to xlim and
    ylim if they exceed the bounds (xlim, ylim). If the axis limit
    does not overlap with (xlim, ylim), the new limits are set to
    (xlim, ylim). Otherwise limits are kept as is.

    Parameters
    ----------
    ax : matplotlib.axes.Axes
        The axis to restrict.
    xlim : tuple of float, optional
        Bounds for the x-axis (lower, upper).
    ylim : tuple of float, optional
        Bounds for the y-axis (lower, upper).
    """
    if xlim is not None:
        ax.set_xlim(*new_lims(ax.get_xlim(), xlim), auto=None)
    if ylim is not None:
        ax.set_ylim(*new_lims(ax.get_ylim(), ylim), auto=None)


def contour_levels(x, y, cls=(0.95, 0.68), bins=None):
    """
    Calculate contour levels corresponding to confidence levels.

    Given 2D datapoints, return values of the pdf corresponding to the
    passed confidence levels.

    Parameters
    ----------
    x : array-like
        x-coordinates of the data points.
    y : array-like
        y-coordinates of the data points.
    cls : tuple of float, optional
        Confidence levels to calculate.
    bins : int, optional
        Number of bins for the 2D histogram. If None, calculated automatically.

    Returns
    -------
    list of float
        Contour levels corresponding to the confidence levels.
    """
    if bins is None:
        bins = int(np.sqrt(len(x)))
    # Make a 2D normalized histogram
    H, xedges, yedges = np.histogram2d(x, y, bins=bins, normed=True)

    norm = H.sum()  # Find the norm of the sum

    # Take histogram bin membership as proportional to Likelihood
    # This is true when data comes from a Markovian process
    def objective(limit, target):
        w = np.where(H > limit)
        count = H[w]
        return count.sum() - target

    levels = [optimize.bisect(objective, H.min(), H.max(), args=(cl * norm,)) for cl in cls]
    levels.append(H.max())
    return levels


def hp_ticklabels(coord, zoom=False, lonra=None, latra=None, rot=None, poles=True):
    """
    Label coordinates on a Healpy map.

    Parameters
    ----------
    coord : str
        Coordinate system to label (e.g., 'Detector', 'Equatorial', 'Galactic').
    zoom : bool, optional
        Whether the map is zoomed in.
    lonra : tuple of float, optional
        Longitude range of the zoomed-in map (lower, upper).
    latra : tuple of float, optional
        Latitude range of the zoomed-in map (lower, upper).
    rot : tuple of float, optional
        Center of the zoomed-in map.
    poles : bool, optional
        Whether to include poles in the latitude range.
    """
    import healpy as hp
    # Coordinate labels
    ax = plt.gca()
    if zoom:
        # Location of other, fixed coordinate
        lon_offset = rot[0] + lonra[0]
        lat_offset = rot[1] + latra[0]
        # Lon/lat coordinates for labels
        lons = np.arange(np.round(lon_offset), lon_offset + lonra[1] - lonra[0], 2)
        lats = np.arange(np.round(lat_offset), lat_offset + latra[1] - latra[0], 2)
    else:
        lon_offset = -180
        lat_offset = 0

        # Lon/lat coordinates for labels
        lons = np.arange(-150, 181, 30)
        lat_start = 90 if poles else 60
        lats = np.arange(-lat_start, lat_start + 1, 30)

    # Actual text at those coordinates
    if coord == COORD.det:
        llats = 90 - lats
    else:
        llats = lats

    # White outline around text
    pe = [path_effects.Stroke(linewidth=1.5, foreground='white'),
          path_effects.Normal()]
    for _ in zip(lats, llats):
        hp.projtext(lon_offset, _[0], f"{_[1]:.0f}$^\\circ$",
                    lonlat=True, path_effects=pe)
    if zoom:
        for _ in lons:
            hp.projtext(_, lat_offset,
                        f"{_:.0f}$^\\circ$", lonlat=True,
                        path_effects=pe)
    else:
        ax.annotate(r"$\bf{-180^\circ}$", xy=(1.7, 0.625), size="medium")
        ax.annotate(r"$\bf{180^\circ}$", xy=(-1.95, 0.625), size="medium")
    ax.annotate(coord, xy=(0.8, -0.05),
                size="medium", xycoords="axes fraction")
